// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef PROTOBUF_msg_2eproto__INCLUDED
#define PROTOBUF_msg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace demo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_msg_2eproto();
void protobuf_AssignDesc_msg_2eproto();
void protobuf_ShutdownFile_msg_2eproto();

class CreateRoomReq;
class CreateRoomRsp;
class EnterRoomReq;
class EnterRoomRsp;
class Cards;
class PlayCardReq;
class PlayCardRsp;
class Test;
class Test_OptionalGroup;

// ===================================================================

class CreateRoomReq : public ::google::protobuf::Message {
 public:
  CreateRoomReq();
  virtual ~CreateRoomReq();

  CreateRoomReq(const CreateRoomReq& from);

  inline CreateRoomReq& operator=(const CreateRoomReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomReq& default_instance();

  void Swap(CreateRoomReq* other);

  // implements Message ----------------------------------------------

  CreateRoomReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoomReq& from);
  void MergeFrom(const CreateRoomReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string UserID = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required int32 RoomType = 2 [default = 1];
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 2;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:demo.CreateRoomReq)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* userid_;
  ::google::protobuf::int32 roomtype_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CreateRoomReq* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoomRsp : public ::google::protobuf::Message {
 public:
  CreateRoomRsp();
  virtual ~CreateRoomRsp();

  CreateRoomRsp(const CreateRoomRsp& from);

  inline CreateRoomRsp& operator=(const CreateRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomRsp& default_instance();

  void Swap(CreateRoomRsp* other);

  // implements Message ----------------------------------------------

  CreateRoomRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoomRsp& from);
  void MergeFrom(const CreateRoomRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required string RoomNum = 2;
  inline bool has_roomnum() const;
  inline void clear_roomnum();
  static const int kRoomNumFieldNumber = 2;
  inline const ::std::string& roomnum() const;
  inline void set_roomnum(const ::std::string& value);
  inline void set_roomnum(const char* value);
  inline void set_roomnum(const char* value, size_t size);
  inline ::std::string* mutable_roomnum();
  inline ::std::string* release_roomnum();
  inline void set_allocated_roomnum(::std::string* roomnum);

  // @@protoc_insertion_point(class_scope:demo.CreateRoomRsp)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_roomnum();
  inline void clear_has_roomnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* roomnum_;
  ::google::protobuf::int32 code_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CreateRoomRsp* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoomReq : public ::google::protobuf::Message {
 public:
  EnterRoomReq();
  virtual ~EnterRoomReq();

  EnterRoomReq(const EnterRoomReq& from);

  inline EnterRoomReq& operator=(const EnterRoomReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoomReq& default_instance();

  void Swap(EnterRoomReq* other);

  // implements Message ----------------------------------------------

  EnterRoomReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoomReq& from);
  void MergeFrom(const EnterRoomReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string UserID = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required int32 RoomType = 2 [default = 1];
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 2;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // required string RoomNum = 3;
  inline bool has_roomnum() const;
  inline void clear_roomnum();
  static const int kRoomNumFieldNumber = 3;
  inline const ::std::string& roomnum() const;
  inline void set_roomnum(const ::std::string& value);
  inline void set_roomnum(const char* value);
  inline void set_roomnum(const char* value, size_t size);
  inline ::std::string* mutable_roomnum();
  inline ::std::string* release_roomnum();
  inline void set_allocated_roomnum(::std::string* roomnum);

  // @@protoc_insertion_point(class_scope:demo.EnterRoomReq)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_roomnum();
  inline void clear_has_roomnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* userid_;
  ::std::string* roomnum_;
  ::google::protobuf::int32 roomtype_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static EnterRoomReq* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoomRsp : public ::google::protobuf::Message {
 public:
  EnterRoomRsp();
  virtual ~EnterRoomRsp();

  EnterRoomRsp(const EnterRoomRsp& from);

  inline EnterRoomRsp& operator=(const EnterRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoomRsp& default_instance();

  void Swap(EnterRoomRsp* other);

  // implements Message ----------------------------------------------

  EnterRoomRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoomRsp& from);
  void MergeFrom(const EnterRoomRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:demo.EnterRoomRsp)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 code_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static EnterRoomRsp* default_instance_;
};
// -------------------------------------------------------------------

class Cards : public ::google::protobuf::Message {
 public:
  Cards();
  virtual ~Cards();

  Cards(const Cards& from);

  inline Cards& operator=(const Cards& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cards& default_instance();

  void Swap(Cards* other);

  // implements Message ----------------------------------------------

  Cards* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cards& from);
  void MergeFrom(const Cards& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 card = 1;
  inline int card_size() const;
  inline void clear_card();
  static const int kCardFieldNumber = 1;
  inline ::google::protobuf::int32 card(int index) const;
  inline void set_card(int index, ::google::protobuf::int32 value);
  inline void add_card(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      card() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_card();

  // @@protoc_insertion_point(class_scope:demo.Cards)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > card_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Cards* default_instance_;
};
// -------------------------------------------------------------------

class PlayCardReq : public ::google::protobuf::Message {
 public:
  PlayCardReq();
  virtual ~PlayCardReq();

  PlayCardReq(const PlayCardReq& from);

  inline PlayCardReq& operator=(const PlayCardReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayCardReq& default_instance();

  void Swap(PlayCardReq* other);

  // implements Message ----------------------------------------------

  PlayCardReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayCardReq& from);
  void MergeFrom(const PlayCardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .demo.Cards card = 1;
  inline bool has_card() const;
  inline void clear_card();
  static const int kCardFieldNumber = 1;
  inline const ::demo::Cards& card() const;
  inline ::demo::Cards* mutable_card();
  inline ::demo::Cards* release_card();
  inline void set_allocated_card(::demo::Cards* card);

  // @@protoc_insertion_point(class_scope:demo.PlayCardReq)
 private:
  inline void set_has_card();
  inline void clear_has_card();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::demo::Cards* card_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static PlayCardReq* default_instance_;
};
// -------------------------------------------------------------------

class PlayCardRsp : public ::google::protobuf::Message {
 public:
  PlayCardRsp();
  virtual ~PlayCardRsp();

  PlayCardRsp(const PlayCardRsp& from);

  inline PlayCardRsp& operator=(const PlayCardRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayCardRsp& default_instance();

  void Swap(PlayCardRsp* other);

  // implements Message ----------------------------------------------

  PlayCardRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayCardRsp& from);
  void MergeFrom(const PlayCardRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:demo.PlayCardRsp)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 code_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static PlayCardRsp* default_instance_;
};
// -------------------------------------------------------------------

class Test_OptionalGroup : public ::google::protobuf::Message {
 public:
  Test_OptionalGroup();
  virtual ~Test_OptionalGroup();

  Test_OptionalGroup(const Test_OptionalGroup& from);

  inline Test_OptionalGroup& operator=(const Test_OptionalGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Test_OptionalGroup& default_instance();

  void Swap(Test_OptionalGroup* other);

  // implements Message ----------------------------------------------

  Test_OptionalGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Test_OptionalGroup& from);
  void MergeFrom(const Test_OptionalGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string RequiredField = 5;
  inline bool has_requiredfield() const;
  inline void clear_requiredfield();
  static const int kRequiredFieldFieldNumber = 5;
  inline const ::std::string& requiredfield() const;
  inline void set_requiredfield(const ::std::string& value);
  inline void set_requiredfield(const char* value);
  inline void set_requiredfield(const char* value, size_t size);
  inline ::std::string* mutable_requiredfield();
  inline ::std::string* release_requiredfield();
  inline void set_allocated_requiredfield(::std::string* requiredfield);

  // @@protoc_insertion_point(class_scope:demo.Test.OptionalGroup)
 private:
  inline void set_has_requiredfield();
  inline void clear_has_requiredfield();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* requiredfield_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Test_OptionalGroup* default_instance_;
};
// -------------------------------------------------------------------

class Test : public ::google::protobuf::Message {
 public:
  Test();
  virtual ~Test();

  Test(const Test& from);

  inline Test& operator=(const Test& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Test& default_instance();

  void Swap(Test* other);

  // implements Message ----------------------------------------------

  Test* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Test& from);
  void MergeFrom(const Test& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Test_OptionalGroup OptionalGroup;

  // accessors -------------------------------------------------------

  // required string label = 1;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 1;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional int32 type = 2 [default = 77];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated int64 reps = 3;
  inline int reps_size() const;
  inline void clear_reps();
  static const int kRepsFieldNumber = 3;
  inline ::google::protobuf::int64 reps(int index) const;
  inline void set_reps(int index, ::google::protobuf::int64 value);
  inline void add_reps(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      reps() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_reps();

  // optional group OptionalGroup = 4 {
  inline bool has_optionalgroup() const;
  inline void clear_optionalgroup();
  static const int kOptionalgroupFieldNumber = 4;
  inline const ::demo::Test_OptionalGroup& optionalgroup() const;
  inline ::demo::Test_OptionalGroup* mutable_optionalgroup();
  inline ::demo::Test_OptionalGroup* release_optionalgroup();
  inline void set_allocated_optionalgroup(::demo::Test_OptionalGroup* optionalgroup);

  // @@protoc_insertion_point(class_scope:demo.Test)
 private:
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_optionalgroup();
  inline void clear_has_optionalgroup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* label_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > reps_;
  ::demo::Test_OptionalGroup* optionalgroup_;
  ::google::protobuf::int32 type_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Test* default_instance_;
};
// ===================================================================


// ===================================================================

// CreateRoomReq

// required string UserID = 1;
inline bool CreateRoomReq::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomReq::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomReq::clear_userid() {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& CreateRoomReq::userid() const {
  // @@protoc_insertion_point(field_get:demo.CreateRoomReq.UserID)
  return *userid_;
}
inline void CreateRoomReq::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set:demo.CreateRoomReq.UserID)
}
inline void CreateRoomReq::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set_char:demo.CreateRoomReq.UserID)
}
inline void CreateRoomReq::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:demo.CreateRoomReq.UserID)
}
inline ::std::string* CreateRoomReq::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:demo.CreateRoomReq.UserID)
  return userid_;
}
inline ::std::string* CreateRoomReq::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateRoomReq::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:demo.CreateRoomReq.UserID)
}

// required int32 RoomType = 2 [default = 1];
inline bool CreateRoomReq::has_roomtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoomReq::set_has_roomtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoomReq::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoomReq::clear_roomtype() {
  roomtype_ = 1;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 CreateRoomReq::roomtype() const {
  // @@protoc_insertion_point(field_get:demo.CreateRoomReq.RoomType)
  return roomtype_;
}
inline void CreateRoomReq::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
  // @@protoc_insertion_point(field_set:demo.CreateRoomReq.RoomType)
}

// -------------------------------------------------------------------

// CreateRoomRsp

// required int32 Code = 1;
inline bool CreateRoomRsp::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomRsp::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomRsp::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomRsp::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 CreateRoomRsp::code() const {
  // @@protoc_insertion_point(field_get:demo.CreateRoomRsp.Code)
  return code_;
}
inline void CreateRoomRsp::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:demo.CreateRoomRsp.Code)
}

// required string RoomNum = 2;
inline bool CreateRoomRsp::has_roomnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoomRsp::set_has_roomnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoomRsp::clear_has_roomnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoomRsp::clear_roomnum() {
  if (roomnum_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomnum_->clear();
  }
  clear_has_roomnum();
}
inline const ::std::string& CreateRoomRsp::roomnum() const {
  // @@protoc_insertion_point(field_get:demo.CreateRoomRsp.RoomNum)
  return *roomnum_;
}
inline void CreateRoomRsp::set_roomnum(const ::std::string& value) {
  set_has_roomnum();
  if (roomnum_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomnum_ = new ::std::string;
  }
  roomnum_->assign(value);
  // @@protoc_insertion_point(field_set:demo.CreateRoomRsp.RoomNum)
}
inline void CreateRoomRsp::set_roomnum(const char* value) {
  set_has_roomnum();
  if (roomnum_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomnum_ = new ::std::string;
  }
  roomnum_->assign(value);
  // @@protoc_insertion_point(field_set_char:demo.CreateRoomRsp.RoomNum)
}
inline void CreateRoomRsp::set_roomnum(const char* value, size_t size) {
  set_has_roomnum();
  if (roomnum_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomnum_ = new ::std::string;
  }
  roomnum_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:demo.CreateRoomRsp.RoomNum)
}
inline ::std::string* CreateRoomRsp::mutable_roomnum() {
  set_has_roomnum();
  if (roomnum_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomnum_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:demo.CreateRoomRsp.RoomNum)
  return roomnum_;
}
inline ::std::string* CreateRoomRsp::release_roomnum() {
  clear_has_roomnum();
  if (roomnum_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = roomnum_;
    roomnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateRoomRsp::set_allocated_roomnum(::std::string* roomnum) {
  if (roomnum_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete roomnum_;
  }
  if (roomnum) {
    set_has_roomnum();
    roomnum_ = roomnum;
  } else {
    clear_has_roomnum();
    roomnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:demo.CreateRoomRsp.RoomNum)
}

// -------------------------------------------------------------------

// EnterRoomReq

// required string UserID = 1;
inline bool EnterRoomReq::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoomReq::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoomReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoomReq::clear_userid() {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& EnterRoomReq::userid() const {
  // @@protoc_insertion_point(field_get:demo.EnterRoomReq.UserID)
  return *userid_;
}
inline void EnterRoomReq::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set:demo.EnterRoomReq.UserID)
}
inline void EnterRoomReq::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set_char:demo.EnterRoomReq.UserID)
}
inline void EnterRoomReq::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:demo.EnterRoomReq.UserID)
}
inline ::std::string* EnterRoomReq::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:demo.EnterRoomReq.UserID)
  return userid_;
}
inline ::std::string* EnterRoomReq::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EnterRoomReq::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:demo.EnterRoomReq.UserID)
}

// required int32 RoomType = 2 [default = 1];
inline bool EnterRoomReq::has_roomtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoomReq::set_has_roomtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterRoomReq::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterRoomReq::clear_roomtype() {
  roomtype_ = 1;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 EnterRoomReq::roomtype() const {
  // @@protoc_insertion_point(field_get:demo.EnterRoomReq.RoomType)
  return roomtype_;
}
inline void EnterRoomReq::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
  // @@protoc_insertion_point(field_set:demo.EnterRoomReq.RoomType)
}

// required string RoomNum = 3;
inline bool EnterRoomReq::has_roomnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterRoomReq::set_has_roomnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterRoomReq::clear_has_roomnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterRoomReq::clear_roomnum() {
  if (roomnum_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomnum_->clear();
  }
  clear_has_roomnum();
}
inline const ::std::string& EnterRoomReq::roomnum() const {
  // @@protoc_insertion_point(field_get:demo.EnterRoomReq.RoomNum)
  return *roomnum_;
}
inline void EnterRoomReq::set_roomnum(const ::std::string& value) {
  set_has_roomnum();
  if (roomnum_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomnum_ = new ::std::string;
  }
  roomnum_->assign(value);
  // @@protoc_insertion_point(field_set:demo.EnterRoomReq.RoomNum)
}
inline void EnterRoomReq::set_roomnum(const char* value) {
  set_has_roomnum();
  if (roomnum_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomnum_ = new ::std::string;
  }
  roomnum_->assign(value);
  // @@protoc_insertion_point(field_set_char:demo.EnterRoomReq.RoomNum)
}
inline void EnterRoomReq::set_roomnum(const char* value, size_t size) {
  set_has_roomnum();
  if (roomnum_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomnum_ = new ::std::string;
  }
  roomnum_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:demo.EnterRoomReq.RoomNum)
}
inline ::std::string* EnterRoomReq::mutable_roomnum() {
  set_has_roomnum();
  if (roomnum_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomnum_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:demo.EnterRoomReq.RoomNum)
  return roomnum_;
}
inline ::std::string* EnterRoomReq::release_roomnum() {
  clear_has_roomnum();
  if (roomnum_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = roomnum_;
    roomnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EnterRoomReq::set_allocated_roomnum(::std::string* roomnum) {
  if (roomnum_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete roomnum_;
  }
  if (roomnum) {
    set_has_roomnum();
    roomnum_ = roomnum;
  } else {
    clear_has_roomnum();
    roomnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:demo.EnterRoomReq.RoomNum)
}

// -------------------------------------------------------------------

// EnterRoomRsp

// required int32 code = 1;
inline bool EnterRoomRsp::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoomRsp::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoomRsp::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoomRsp::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 EnterRoomRsp::code() const {
  // @@protoc_insertion_point(field_get:demo.EnterRoomRsp.code)
  return code_;
}
inline void EnterRoomRsp::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:demo.EnterRoomRsp.code)
}

// -------------------------------------------------------------------

// Cards

// repeated int32 card = 1;
inline int Cards::card_size() const {
  return card_.size();
}
inline void Cards::clear_card() {
  card_.Clear();
}
inline ::google::protobuf::int32 Cards::card(int index) const {
  // @@protoc_insertion_point(field_get:demo.Cards.card)
  return card_.Get(index);
}
inline void Cards::set_card(int index, ::google::protobuf::int32 value) {
  card_.Set(index, value);
  // @@protoc_insertion_point(field_set:demo.Cards.card)
}
inline void Cards::add_card(::google::protobuf::int32 value) {
  card_.Add(value);
  // @@protoc_insertion_point(field_add:demo.Cards.card)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Cards::card() const {
  // @@protoc_insertion_point(field_list:demo.Cards.card)
  return card_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Cards::mutable_card() {
  // @@protoc_insertion_point(field_mutable_list:demo.Cards.card)
  return &card_;
}

// -------------------------------------------------------------------

// PlayCardReq

// required .demo.Cards card = 1;
inline bool PlayCardReq::has_card() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayCardReq::set_has_card() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayCardReq::clear_has_card() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayCardReq::clear_card() {
  if (card_ != NULL) card_->::demo::Cards::Clear();
  clear_has_card();
}
inline const ::demo::Cards& PlayCardReq::card() const {
  // @@protoc_insertion_point(field_get:demo.PlayCardReq.card)
  return card_ != NULL ? *card_ : *default_instance_->card_;
}
inline ::demo::Cards* PlayCardReq::mutable_card() {
  set_has_card();
  if (card_ == NULL) card_ = new ::demo::Cards;
  // @@protoc_insertion_point(field_mutable:demo.PlayCardReq.card)
  return card_;
}
inline ::demo::Cards* PlayCardReq::release_card() {
  clear_has_card();
  ::demo::Cards* temp = card_;
  card_ = NULL;
  return temp;
}
inline void PlayCardReq::set_allocated_card(::demo::Cards* card) {
  delete card_;
  card_ = card;
  if (card) {
    set_has_card();
  } else {
    clear_has_card();
  }
  // @@protoc_insertion_point(field_set_allocated:demo.PlayCardReq.card)
}

// -------------------------------------------------------------------

// PlayCardRsp

// required int32 Code = 1;
inline bool PlayCardRsp::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayCardRsp::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayCardRsp::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayCardRsp::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 PlayCardRsp::code() const {
  // @@protoc_insertion_point(field_get:demo.PlayCardRsp.Code)
  return code_;
}
inline void PlayCardRsp::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:demo.PlayCardRsp.Code)
}

// -------------------------------------------------------------------

// Test_OptionalGroup

// required string RequiredField = 5;
inline bool Test_OptionalGroup::has_requiredfield() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test_OptionalGroup::set_has_requiredfield() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test_OptionalGroup::clear_has_requiredfield() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test_OptionalGroup::clear_requiredfield() {
  if (requiredfield_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requiredfield_->clear();
  }
  clear_has_requiredfield();
}
inline const ::std::string& Test_OptionalGroup::requiredfield() const {
  // @@protoc_insertion_point(field_get:demo.Test.OptionalGroup.RequiredField)
  return *requiredfield_;
}
inline void Test_OptionalGroup::set_requiredfield(const ::std::string& value) {
  set_has_requiredfield();
  if (requiredfield_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requiredfield_ = new ::std::string;
  }
  requiredfield_->assign(value);
  // @@protoc_insertion_point(field_set:demo.Test.OptionalGroup.RequiredField)
}
inline void Test_OptionalGroup::set_requiredfield(const char* value) {
  set_has_requiredfield();
  if (requiredfield_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requiredfield_ = new ::std::string;
  }
  requiredfield_->assign(value);
  // @@protoc_insertion_point(field_set_char:demo.Test.OptionalGroup.RequiredField)
}
inline void Test_OptionalGroup::set_requiredfield(const char* value, size_t size) {
  set_has_requiredfield();
  if (requiredfield_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requiredfield_ = new ::std::string;
  }
  requiredfield_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:demo.Test.OptionalGroup.RequiredField)
}
inline ::std::string* Test_OptionalGroup::mutable_requiredfield() {
  set_has_requiredfield();
  if (requiredfield_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requiredfield_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:demo.Test.OptionalGroup.RequiredField)
  return requiredfield_;
}
inline ::std::string* Test_OptionalGroup::release_requiredfield() {
  clear_has_requiredfield();
  if (requiredfield_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = requiredfield_;
    requiredfield_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Test_OptionalGroup::set_allocated_requiredfield(::std::string* requiredfield) {
  if (requiredfield_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete requiredfield_;
  }
  if (requiredfield) {
    set_has_requiredfield();
    requiredfield_ = requiredfield;
  } else {
    clear_has_requiredfield();
    requiredfield_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:demo.Test.OptionalGroup.RequiredField)
}

// -------------------------------------------------------------------

// Test

// required string label = 1;
inline bool Test::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test::clear_label() {
  if (label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& Test::label() const {
  // @@protoc_insertion_point(field_get:demo.Test.label)
  return *label_;
}
inline void Test::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
  // @@protoc_insertion_point(field_set:demo.Test.label)
}
inline void Test::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
  // @@protoc_insertion_point(field_set_char:demo.Test.label)
}
inline void Test::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:demo.Test.label)
}
inline ::std::string* Test::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:demo.Test.label)
  return label_;
}
inline ::std::string* Test::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Test::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:demo.Test.label)
}

// optional int32 type = 2 [default = 77];
inline bool Test::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test::clear_type() {
  type_ = 77;
  clear_has_type();
}
inline ::google::protobuf::int32 Test::type() const {
  // @@protoc_insertion_point(field_get:demo.Test.type)
  return type_;
}
inline void Test::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:demo.Test.type)
}

// repeated int64 reps = 3;
inline int Test::reps_size() const {
  return reps_.size();
}
inline void Test::clear_reps() {
  reps_.Clear();
}
inline ::google::protobuf::int64 Test::reps(int index) const {
  // @@protoc_insertion_point(field_get:demo.Test.reps)
  return reps_.Get(index);
}
inline void Test::set_reps(int index, ::google::protobuf::int64 value) {
  reps_.Set(index, value);
  // @@protoc_insertion_point(field_set:demo.Test.reps)
}
inline void Test::add_reps(::google::protobuf::int64 value) {
  reps_.Add(value);
  // @@protoc_insertion_point(field_add:demo.Test.reps)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Test::reps() const {
  // @@protoc_insertion_point(field_list:demo.Test.reps)
  return reps_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Test::mutable_reps() {
  // @@protoc_insertion_point(field_mutable_list:demo.Test.reps)
  return &reps_;
}

// optional group OptionalGroup = 4 {
inline bool Test::has_optionalgroup() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Test::set_has_optionalgroup() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Test::clear_has_optionalgroup() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Test::clear_optionalgroup() {
  if (optionalgroup_ != NULL) optionalgroup_->::demo::Test_OptionalGroup::Clear();
  clear_has_optionalgroup();
}
inline const ::demo::Test_OptionalGroup& Test::optionalgroup() const {
  // @@protoc_insertion_point(field_get:demo.Test.optionalgroup)
  return optionalgroup_ != NULL ? *optionalgroup_ : *default_instance_->optionalgroup_;
}
inline ::demo::Test_OptionalGroup* Test::mutable_optionalgroup() {
  set_has_optionalgroup();
  if (optionalgroup_ == NULL) optionalgroup_ = new ::demo::Test_OptionalGroup;
  // @@protoc_insertion_point(field_mutable:demo.Test.optionalgroup)
  return optionalgroup_;
}
inline ::demo::Test_OptionalGroup* Test::release_optionalgroup() {
  clear_has_optionalgroup();
  ::demo::Test_OptionalGroup* temp = optionalgroup_;
  optionalgroup_ = NULL;
  return temp;
}
inline void Test::set_allocated_optionalgroup(::demo::Test_OptionalGroup* optionalgroup) {
  delete optionalgroup_;
  optionalgroup_ = optionalgroup;
  if (optionalgroup) {
    set_has_optionalgroup();
  } else {
    clear_has_optionalgroup();
  }
  // @@protoc_insertion_point(field_set_allocated:demo.Test.optionalgroup)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace demo

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_msg_2eproto__INCLUDED
